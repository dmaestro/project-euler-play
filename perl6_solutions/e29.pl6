# Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#
#     2²=4, 2³=8, 2⁴=16, 2⁵=32
#     3²=9, 3³=27, 3⁴=81, 3⁵=243
#     4²=16, 4³=64, 4⁴=256, 4⁵=1024
#     5²=25, 5³=125, 5⁴=625, 5⁵=3125
#
# If they are then placed in numerical order, with any repeats removed,
# we get the following sequence of 15 distinct terms:
#
# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
#
# How many distinct terms are in the sequence generated by ab
# for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

subset Nat of Int where * > 0 ;

# Matrix lookup
# NOTE: this overrides array slices !!
multi postcircumfix:<[ ]>(Positional $ary, List $coord) {
#   say 'src, crsr: ', ( $ary.perl, $coord.perl );
    zip $ary, $coord.flat, :with( {
    #   say 'ary, index: ', ( $^a.perl, $^i.WHICH );
        $^a[$^i]
    } );
}

sub infix:<outside>(List $coord, List $boundary) {
    fail if $coord.elems != $boundary.elems;
    so any( $coord.flat Z< $boundary.flat );
}

sub unit_vectors(+@coordinate) {
    @coordinate.perl.say;
    gather {
        for @coordinate.keys -> $i {
            take eager map { +($_ == $i) }, @coordinate.keys;
        }
    }
}

sub new_boundary(&v, @cursor) {
    my $current_value = v( @cursor);
    say "Current: $current_value";
    my @boundaries = gather {
      while $current_value eqv v( @cursor ) {
        say "Diagonal {@cursor}";
        for unit_vectors(@cursor) -> $vector {
        #   $vector.perl.say;
            my @new_cursor = @cursor;
            repeat while my $new_value eqv $current_value {
                @new_cursor = @new_cursor Z+ $vector.flat;
                $new_value = v( @new_cursor);
                say "New: {@new_cursor} => $new_value"
                    if $new_value.defined;
            }
            take @new_cursor if $new_value.defined;
        }
        @cursor = @cursor.flat Z+ (1 xx @cursor.elems);
      }
      take @cursor if v( @cursor ).defined;
    }
    say "All: {@boundaries}";
    for ^(@boundaries.elems) -> $i {
        say "Except [$i]: ", @boundaries.grep: * !eqv @boundaries[$i];
    }
    return eager @boundaries.grep: -> $test { $test outside all( @boundaries.grep: * !eqv $test ) }
}

# start with [0, 0] as boundary
# select minumum boundary coordinate
# compute value and take source values at that coordinate
# while boundary_value.min exists
#   if min value == current value
#       replace the boundary coord with new boundaries

sub combine_sort(&f, **@sources where { $_.all ~~ List }) {
    return if 0 == any(@sources».elems);
    my &v = sub (@where) {
        return if Any ~~ any(@sources[@where]);
    #   say $(@where);
        f( |@sources[@where] )
    };
    push my @boundaries, 0 xx @sources.elems;
    while (@boundaries) {
        say 'Boundaries: ', @boundaries;
        my @cursor = |@boundaries.min: &v;
        @boundaries = @boundaries.grep: { $_.List !eqv @cursor.List };
    #   say 'Sources: ', @sources;
        say 'Cursor: ', @cursor, ' => ', v( @cursor );
        take @sources[ @cursor ];
        my @new = new_boundary(&v, @cursor.clone).grep: * outside all(@boundaries);
        say 'Cursor: ', @cursor, ' => ', v( @cursor );
        say "Acceptable: ", @new;
        push @boundaries, |@new;
        last if ++$ > 6;
    }
}

my @test = [
    [ 1, 1, 1, 1, 2, 6 ],
    [ 1, 4, 6, 6, 6, 9 ],
    [ 4, 5, 6, 7, 8, 9 ],
    [ 6, 6, 6, 7, 9, 11 ],
    [ 9, 10, 11, 11, 11, 11 ],
];

sub MAIN(Nat :$limit where * > 1 = 100) {
    say gather combine_sort { #`<say "f: ", ($^x, $^y);> @test[ $^x][ $^y ] }, [^5], [^6] ;
#   say "Unit(1): ", unit_vectors((^1).reverse);
#   say "Unit(2): ", unit_vectors((^2).reverse);
#   say "Unit(3): ", unit_vectors((^3).reverse);
#   say "Unit(4): ", unit_vectors((^4).reverse);
}
